## การทำงานของ emulsiV

#### แสดงผลตัวอักษร T และ P

#### คธิบายคำสั่ง

    addi x1, x0, 32 (add immediate) คำสั่งนี้ จะนำเลข 32(ฐาน10) บวกกับ x0 เเล้วนำค่าไปใส่ใน x1 
    lui x2, 0xc0000000 (load upper immediate ) คำสั่งนี้ จะนำค่าทางขวามือ มาเก็บไว้ที่ x2 เเค่ 20 bit เเรก
    lbu x3, 0(x1) (load byte unsigned) คำสั่งนี้จะเอาหน่วยความจำจาก x1 ไปใส่ใน x3 เเค่ byte เดียว
    beq x3, x0, +16 (branch on equal)  คำสั่งนี้จะเป็นการเทียบถ้า x3 = x0 จะกระโดดจาก address ปัจจุบันไปข้างหน้า 16 ช่อง
    sb x3, 0(x2) (store byte) คำสั่งนี้ จะนำข้อมูลใน x3(ที่ไม่เท่ากับ0) ไปเก็บไว้ใน address x2
    addi x1, x1, 1 คำสั่งนี้จะนำเลข 1 บวกกับ x1 เเล้วนำค่าไปใส่ใน x1 
    jal x0, -16 (jump and link) คำสั่งนี้ จะกระโดดจากตำแหน่งเดิมเดิม ถอยไป 16 ช่อง
    jal x0, 0 โดยคำสั่งนี้จะกระโดดอยู่กับที่เหมือนเป็นการวนซ้ำหรือจบโปรเเกรม

### Step 1

    1.เมื่อเรียกคำสั่งที่ 1 (00000000) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 00000000 (93000002) มาเรียงใหม่จากหลังมาหน้า (02000093) ในตำเเหน่งของ data ที่ Bus 

    3. ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง addi x1, x0, 32 
    
    4.สิ่งที่ได้คือ ALU จะทราบว่า op ที่ใช้คือ add จากนั้นจะเรียกค่า x0  ไปใส่ใน a และเรียกค่า imm(32ฐาน10 เเปลงเป็ยฐาน 16) เป็นตัวบวกเพิ่มที่ b 
    
    เมื่อบวกกันเเล้ว ผลลัพธ์จะไปอยู่ในค่า r  เเละนำค่า r ไปใส่ไว้ใน x1
    
    5.เมื่อเสร็จคำสั่งเเรก ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่2
   
   ![image](https://user-images.githubusercontent.com/98943509/160230704-d7337742-a16e-4beb-b84b-3632daca1b62.png)
  
  ![image](https://user-images.githubusercontent.com/98943509/160230834-0411e948-ca81-4317-a124-aad8833cf321.png)
    

### Step 2

    1.เมื่อเรียกคำสั่งที่ 2 (00000004) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 00000004 (370100c0) มาเรียงใหม่จากหลังมาหน้า (c0000137) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง  lui x2, 0xc0000000 
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ b โดยจะเรียกค่า b มาจาก imm(c0000000) มาใส่เป็น ค่า r เเละนำค่า r(c0000000) ไปใส่ไว้ใน x2
    
    5.เมื่อเสร็จคำสั่งที่2 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่3
  
  ![image](https://user-images.githubusercontent.com/98943509/160230834-0411e948-ca81-4317-a124-aad8833cf321.png)
  ![image](https://user-images.githubusercontent.com/98943509/160231292-702d3a8c-8c06-4f46-b539-d2f8578d1fb9.png)


### Step 3

    1.เมื่อเรียกคำสั่งที่ 3 (00000008) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 00000008 (83c10000) มาเรียงใหม่จากหลังมาหน้า (0000c183) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง lbu x3, 0(x1)
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a จาก x1(00000020) บวกกับค่า b มาจาก imm(00000000) นำผลลัพธ์ใส่ใน ค่า r (00000020)
    
    5.ค่าของ r(00000020) ประมวณผลที่ Bus เรียก data(00000054)  ไปใส่ใน x3
    
    6.เมื่อเสร็จคำสั่งที่ 3 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 4
  
![image](https://user-images.githubusercontent.com/98943509/160231292-702d3a8c-8c06-4f46-b539-d2f8578d1fb9.png)
![image](https://user-images.githubusercontent.com/98943509/160231828-45f578bb-5a33-4453-99c1-6cbc5d2280bc.png)


### Step 4

    1.เมื่อเรียกคำสั่งที่ 4 (0000000c) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 0000000c (63880100) มาเรียงใหม่จากหลังมาหน้า (00018863) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง beq x3, x0, +16
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเพิ่มค่าจาก addressเดิม(0000000c) jumpไปข้างหน้า 16 ช่อง นำค่าที่ได้ใส่ใน r(0000001c)
    
    5.จากนั้นจะทำการเปรียบเทียบ  x0 กับ x3 ว่าเท่ากันหรือไม่ ซึ่งในตัวอย่างจะไม่เท่ากัน ทำให้ไม่เกิดการ jumpไปข้างหน้า 16 ช่อง
    
    6.เมื่อเสร็จคำสั่งที่ 4 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 5

![image](https://user-images.githubusercontent.com/98943509/160231828-45f578bb-5a33-4453-99c1-6cbc5d2280bc.png)
![image](https://user-images.githubusercontent.com/98943509/160232174-3250ac2f-617b-4788-8750-72bfcc44ef44.png)



### Step 5

    1.เมื่อเรียกคำสั่งที่ 5 (00000010) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 000000010 (23003100) มาเรียงใหม่จากหลังมาหน้า (00310023) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง sb x3, 0(x2)
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a จาก x2(c0000000) บวกกับค่า b มาจาก imm(00000000) นำผลลัพธ์ใส่ใน ค่า r (c0000000)
    
    5. จากนั้นจะนำค่า x3(00000054) ไปใส่ใน r หรือ x2 ซึ่งค่า x2(c0000000) จะเป็นการเเสดงผลที่หน้าจอ ได้ตัวอักษร T
    
    6.เมื่อเสร็จคำสั่งที่ 5 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 6
  
![image](https://user-images.githubusercontent.com/98943509/160232174-3250ac2f-617b-4788-8750-72bfcc44ef44.png)
![image](https://user-images.githubusercontent.com/98943509/160232556-8e801ea9-0236-4c8e-93fe-69454fbc8af0.png)

### Step 6

    1.เมื่อเรียกคำสั่งที่ 6 (00000014) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 000000014 (93801000) มาเรียงใหม่จากหลังมาหน้า (00108093) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง addi x1, x1, 1
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add  โดยนำค่าจาก x1 (00000020)ที่ต่ำเเหน่ง a มาบวกเพิ่ม 1 ที่ตำแหน่ง ค่า r(00000021) ที่ได้ จะนำไปใส่ใน x1
    
    5.เมื่อเสร็จคำสั่งที่ 6 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 7

![image](https://user-images.githubusercontent.com/98943509/160232556-8e801ea9-0236-4c8e-93fe-69454fbc8af0.png)
![image](https://user-images.githubusercontent.com/98943509/160232723-6c8c6aa2-647d-4ad9-8c95-ff99397f2c8b.png)


### Step 7

    1.เมื่อเรียกคำสั่งที่ 7 (00000018) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 000000018 (6ff01fff) มาเรียงใหม่จากหลังมาหน้า (ff1ff06f) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง jal x0, -16
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าจากตำแหน่งปัจจุบัน (00000018) คือ a  บวกด้วย ลบถอยกลับไป 16 ช่อง คือ b นำผลลัพธ์ใส่ใน ค่า r (00000008)
    
    5.เมื่อเสร็จคำสั่งที่ 4 ค่า pc+4 จะไปแทนที่ค่า pc ซึ่งจะเป็นการย้อนไปเรียกคำสั่งที่ 3 (00000008)
  
  ![image](https://user-images.githubusercontent.com/98943509/160232723-6c8c6aa2-647d-4ad9-8c95-ff99397f2c8b.png)
  ![image](https://user-images.githubusercontent.com/98943509/160233318-0cf92265-13c0-4bda-ad04-f6d9f8f805bc.png)


### Step 8

  
     1.เมื่อเรียกคำสั่งที่ 3 (00000008) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 00000008 (83c10000) มาเรียงใหม่จากหลังมาหน้า (0000c183) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง lbu x3, 0(x1)
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a จาก x1(00000021) บวกกับค่า b มาจาก imm(00000000) นำผลลัพธ์ใส่ใน ค่า r (00000021)
    
    5.ค่าของ r(00000021) ประมวณผลที่ Bus เรียก data(00000050)  ไปใส่ใน x3
    
    6.เมื่อเสร็จคำสั่งที่ 3 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 4
  
![image](https://user-images.githubusercontent.com/98943509/160233318-0cf92265-13c0-4bda-ad04-f6d9f8f805bc.png)
![image](https://user-images.githubusercontent.com/98943509/160233503-c7aa56a4-2229-40bc-bfb5-9d5480183b07.png)


### Step 9

    1.เมื่อเรียกคำสั่งที่ 4 (0000000c) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 0000000c (63880100) มาเรียงใหม่จากหลังมาหน้า (00018863) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง beq x3, x0, +16
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเพิ่มค่าจาก addressเดิม(0000000c) jumpไปข้างหน้า 16 ช่อง นำค่าที่ได้ใส่ใน r(0000001c)
    
    5.จากนั้นจะทำการเปรียบเทียบ  x0 กับ x3 ว่าเท่ากันหรือไม่ ซึ่งในตัวอย่างจะไม่เท่ากัน ทำให้ไม่เกิดการ jumpไปข้างหน้า 16 ช่อง
    
    6.เมื่อเสร็จคำสั่งที่ 4 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 5
  
![image](https://user-images.githubusercontent.com/98943509/160233503-c7aa56a4-2229-40bc-bfb5-9d5480183b07.png)
![image](https://user-images.githubusercontent.com/98943509/160233609-5ecfacfd-bc6d-4abe-b4c7-ff7a5847c8d0.png)


### Step 10
    
    1.เมื่อเรียกคำสั่งที่ 5 (00000010) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 000000010 (23003100) มาเรียงใหม่จากหลังมาหน้า (00310023) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง sb x3, 0(x2)
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a จาก x2(c0000000) บวกกับค่า b มาจาก imm(00000000) นำผลลัพธ์ใส่ใน ค่า r (c0000000)
    
    5. จากนั้นจะนำค่า x3(00000050) ไปใส่ใน r หรือ x2 ซึ่งค่า x2(c0000000) จะเป็นการเเสดงผลที่หน้าจอ ได้ตัวอักษร P
    
    6.เมื่อเสร็จคำสั่งที่ 5 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 6
   
![image](https://user-images.githubusercontent.com/98943509/160233609-5ecfacfd-bc6d-4abe-b4c7-ff7a5847c8d0.png)
![image](https://user-images.githubusercontent.com/98943509/160233782-874a9d18-c371-4f0a-ac21-f39e57780e27.png)

### Step 11
  
    1.เมื่อเรียกคำสั่งที่ 6 (00000014) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 000000014 (93801000) มาเรียงใหม่จากหลังมาหน้า (00108093) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง addi x1, x1, 1
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add  โดยนำค่าจาก x1 (00000021)ที่ต่ำเเหน่ง a มาบวกเพิ่ม 1 ที่ตำแหน่ง ค่า r(00000022) ที่ได้ จะนำไปใส่ใน x1
    
    5.เมื่อเสร็จคำสั่งที่ 6 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 7
 
 ![image](https://user-images.githubusercontent.com/98943509/160233782-874a9d18-c371-4f0a-ac21-f39e57780e27.png)
 ![image](https://user-images.githubusercontent.com/98943509/160233853-dfc96df3-90c9-4ca2-9368-bda2a592d93f.png)


### Step 12
    
    1.เมื่อเรียกคำสั่งที่ 7 (00000018) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 000000018 (6ff01fff) มาเรียงใหม่จากหลังมาหน้า (ff1ff06f) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง jal x0, -16
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยนำค่าจากตำแหน่งปัจจุบัน (00000018) คือ a  บวกด้วย ลบถอยกลับไป 16 ช่อง คือ b นำผลลัพธ์ใส่ใน ค่า r (00000008)
    
    5.เมื่อเสร็จคำสั่งที่ 4 ค่า pc+4 จะไปแทนที่ค่า pc ซึ่งจะเป็นการย้อนไปเรียกคำสั่งที่ 3 (00000008)
  
  ![image](https://user-images.githubusercontent.com/98943509/160233853-dfc96df3-90c9-4ca2-9368-bda2a592d93f.png)
  ![image](https://user-images.githubusercontent.com/98943509/160233934-7b4f9942-fb90-4799-875e-a5e7282d771e.png)


### Step 13
     
    1.เมื่อเรียกคำสั่งที่ 3 (00000008) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 00000008 (83c10000) มาเรียงใหม่จากหลังมาหน้า (0000c183) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง lbu x3, 0(x1)
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเรียกค่า a จาก x1(00000022) บวกกับค่า b มาจาก imm(00000000) นำผลลัพธ์ใส่ใน ค่า r (00000022)
    
    5.ค่าของ r(00000023) ประมวณผลที่ Bus เรียก data(00000000)  ไปใส่ใน x3
    
    6.เมื่อเสร็จคำสั่งที่ 3 ค่า pc+4 จะไปแทนที่ค่า pc เพื่อเรียงคำสั่งที่ 4
  
![image](https://user-images.githubusercontent.com/98943509/160233934-7b4f9942-fb90-4799-875e-a5e7282d771e.png)
![image](https://user-images.githubusercontent.com/98943509/160234077-9c8c0b76-2aa1-4d29-8479-8e6d4c49e936.png)

### Step 14
  
    1.เมื่อเรียกคำสั่งที่ 4 (0000000c) จาก pc 

    2.โปรเเกรมจะนำข้อมูลจาก 0000000c (63880100) มาเรียงใหม่จากหลังมาหน้า (00018863) ในตำเเหน่งของ data ที่ Bus 

    3.ข้อมูลในตำเเหน่ง data ที่ Bus จะถูกส่งไปที่ Instruction req. เพื่อเเปลคำสั่ง beq x3, x0, +16
    
    4.ALU จะทราบว่า op ในครั้งนี้คือ add โดยจะเพิ่มค่าจาก addressเดิม(0000000c) jumpไปข้างหน้า 16 ช่อง นำค่าที่ได้ใส่ใน r(0000001c)
    
    5.จากนั้นจะทำการเปรียบเทียบ  x0 กับ x3 ว่าเท่ากันหรือไม่ ในตอนนี้ ค่า x3 = x0 ดังนั้นต้อง jumpไปข้างหน้า 16 ช่อง ซึ่งเป็นคำสั่งที่ 8
    
    ![image](https://user-images.githubusercontent.com/98943509/160234077-9c8c0b76-2aa1-4d29-8479-8e6d4c49e936.png)
    ![image](https://user-images.githubusercontent.com/98943509/160234331-59c8ce00-e8db-4161-810b-6029f551259f.png)


### ใน step นี้ จะพบคำสั่งที่ 8 (0000001c) ซึ่งคำสั่งนี้จะกระโดดอยู่กับที่เหมือนเป็นการวนซ้ำหรือจบโปรเเกรม
![image](https://user-images.githubusercontent.com/98943509/160234331-59c8ce00-e8db-4161-810b-6029f551259f.png)

